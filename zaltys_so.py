"""Helper functions pertaining to States and Operators needed to run zaltys.
"""

import numpy as np
from math import sqrt
import scipy.sparse as sps

from scipy.special import genlaguerre
from math import exp
from mpmath import rf as rising_factorial


# Constants
SPIN_UP = 1
SPIN_DOWN = -1
CUTOFF_PRECISION = 1e-6


def generate_states(ee_cutoff):
    """Generate states | nx , ny , spin > up to some energy cutoff.

    Args:
        ee_cutoff: Energy cutoff up to (and including) which the states are
        generated.

    Returns:
        A list [ nx_list, ny_list, spin_list ] where a state
        | nx, ny, spin > is e.g. | nx_list[3], ny_list[3], spin_list[3] >
    """
    nx_list = []
    ny_list = []
    spin_list = []

    for ee in range(1, ee_cutoff + 1):
        for nx in range(0, ee):
            ny = ee - nx - 1
            for spin in [SPIN_UP, SPIN_DOWN]:
                nx_list.append(nx)
                ny_list.append(ny)
                spin_list.append(spin)
    return [nx_list, ny_list, spin_list]


def state_index(state):
    """Given a state vector [nx, ny, spin] return its index in the array
    of states.

    Args:
        state: The input state vector.

    Returns:
        An integer index.
    """
    ee = state[0] + state[1] + 1
    index = ee * (ee - 1) + state[0] * 2
    if state[2] == SPIN_DOWN:
        index = index + 1
    return index


def check_indexing(nx_list, ny_list, spin_list):
    """Check if the indexing is correct.

    The ordering is as follows. Lower nx precede higher nx. Spin up
    precedes spin down.

    This method does not return anything, prints out the result.

    Args:
        nx_list: List of nx's, principal quantum numbers with respect to the x
        direction.

        ny_list: List of ny's.

        spin_list: List of spins, 1 for up and -1 for down.
    """
    if len(nx_list) != len(ny_list) or len(nx_list) != len(spin_list):
        print('Error: the lists are of different lengths.')
        return

    for ii in range(0, len(nx_list)):
        if ii != state_index([nx_list[ii], ny_list[ii], spin_list[ii]]):
            print('Error: state_index error at index {}.').format(ii)
            return
    print('State indices are correct.')


def generate_rashba_hamiltonian(v, ee_cutoff, state_list):
    """Construct the Rashba Hamiltonian as a sparse matrix in the Cartesian
    harmonic oscillator basis.

    Args:
        v: Dimensionless Rashba spin-orbit coupling strength in the
        Hamiltonian.

        ee_cutoff: Energy cutoff up to (and including) which the states were
        generated by generate_states.

        state_list: List of principal and spin quantum numbers, cf.
        generate_states.

    Return:
        A sparse matrix in the Compressed Sparse Row (CSR) format.
    """

    # TODO: checking boundary conditions explicitly for now;
    #       it is probably possible to optimize that

    [nx_list, ny_list, spin_list] = state_list

    list_l = []  # left index
    list_r = []  # right index
    list_e = []  # entry

    diag_index = []
    diag_ho_ee = []  # entry on the diagonal, which corresponds to the harmonic
    # oscillator energy

    # left index
    for li in range(0, len(nx_list)):

        # Filling the diagonal with energies
        diag_index.append(li)
        ee = nx_list[li] + ny_list[li] + 1
        diag_ho_ee.append(ee)

        # Filling the SOC part of the Hamiltonian
        if li % 2 == 0:  # if (lv[2] == spinUp)
            if ee < ee_cutoff:
                list_l.append(li)
                # nx == nx', ny == ny' + 1
                ri = state_index([nx_list[li], ny_list[li] + 1, -1])
                list_r.append(ri)
                list_e.append(-1j * (v / np.sqrt(2)) * sqrt(ny_list[li] + 1))
            if ee > 1:
                if ny_list[li] >= 1:
                    list_l.append(li)
                    # nx == nx', ny == ny' - 1
                    ri = state_index([nx_list[li], ny_list[li] - 1, -1])
                    list_r.append(ri)
                    list_e.append(1j * (v / np.sqrt(2)) * sqrt(ny_list[li]))
            if ee < ee_cutoff:
                list_l.append(li)
                # nx == nx' + 1, ny == ny'
                ri = state_index([nx_list[li] + 1, ny_list[li], -1])
                list_r.append(ri)
                list_e.append((v / np.sqrt(2)) * sqrt(nx_list[li] + 1))
            if ee > 1:
                if nx_list[li] >= 1:
                    list_l.append(li)
                    # nx == nx' -1 , ny == ny'
                    ri = state_index([nx_list[li] - 1, ny_list[li], -1])
                    list_r.append(ri)
                    list_e.append(-(v / np.sqrt(2)) * sqrt(nx_list[li]))
        else:
            if (nx_list[li] + ny_list[li] + 1) < ee_cutoff:
                list_l.append(li)
                # nx == nx', ny == ny' + 1
                ri = state_index([nx_list[li], ny_list[li] + 1, 1])
                list_r.append(ri)
                list_e.append(-1j * (v / np.sqrt(2)) * sqrt(ny_list[li] + 1))
            if (nx_list[li] + ny_list[li] + 1) > 1:
                if ny_list[li] >= 1:
                    list_l.append(li)
                    # nx == nx', ny == ny' - 1
                    ri = state_index([nx_list[li], ny_list[li] - 1, 1])
                    list_r.append(ri)
                    list_e.append(1j * (v / np.sqrt(2)) * sqrt(ny_list[li]))
            # Changes minus sign as compared to above
            if (nx_list[li] + ny_list[li] + 1) < ee_cutoff:
                list_l.append(li)
                # nx == nx' + 1, ny == ny'
                ri = state_index([nx_list[li] + 1, ny_list[li], 1])
                list_r.append(ri)
                list_e.append(-(v / np.sqrt(2)) * sqrt(nx_list[li] + 1))
            if (nx_list[li] + ny_list[li] + 1) > 1:
                if nx_list[li] >= 1:
                    list_l.append(li)
                    # nx == nx' - 1, ny == ny'
                    ri = state_index([nx_list[li] - 1, ny_list[li], 1])
                    list_r.append(ri)
                    list_e.append((v / np.sqrt(2)) * sqrt(nx_list[li]))

    H0 = sps.coo_matrix((diag_ho_ee, (diag_index, diag_index)),
                        shape=(len(nx_list), len(nx_list)))

    list_l = np.array(list_l)
    list_r = np.array(list_r)
    list_e = np.array(list_e)

    HR = sps.coo_matrix((list_e, (list_l, list_r)),
                        shape=(len(nx_list), len(nx_list)))

    # returns the CSR format
    return H0 + HR


def _o(x0, m, n):
    """Overlap function between |nx> = m and |nx'> = n under translation in the x
       direction with the amplitude x0.

       Keeping the name indecently short, as this function should not be called
       from outside the module.

    Args:
        x0: translation amplitude.

        m, n: principal quantum numbers for harmonic oscillator states
              to compute overlap between. Note that only the relevant numbers
              (i.e. the ones in x direction without spin) are considered.

    Returns:
        The overlap amplitude, which is always real.
"""
    x0_ = x0 / np.sqrt(2)
    ax02 = abs(x0_)**2
    if m >= n:
        L = genlaguerre(n, m - n)
        return (sqrt(1 / rising_factorial(n + 1, m - n)) * (x0_**(m - n))
                * exp(- ax02 / 2) * L(ax02))
    else:
        L = genlaguerre(m, n - m)
        return (sqrt(1 / rising_factorial(m + 1, n - m)) * ((-x0_)**(n - m))
                * exp(- ax02 / 2) * L(ax02))


def _overlap_lookup(x0, ee_cutoff):
    """The overlap function _o is quite slow, so we precompute its values here.

    Args:
        x0: translation amplitude.

        ee_cutoff: Energy cutoff up to (and including) which the states were
        generated by generate_states.

    Returns:
        A numpy array with overlaps.
    """

    lookup_array = np.zeros((ee_cutoff, ee_cutoff))

    for i1 in np.arange(0, ee_cutoff):
        for i2 in np.arange(0, ee_cutoff):
            nowOverlap = _o(x0, i1, i2)
            if abs(nowOverlap) > CUTOFF_PRECISION:
                lookup_array[i1][i2] = nowOverlap

    return lookup_array


def generate_translation_operator(x0, ee_cutoff, state_list):
    """Construct the translation operator as a sparse matrix in the Cartesian
    harmonic oscillator basis.

    Args:
        x0: translation amplitude.

        ee_cutoff: Energy cutoff up to (and including) which the states were
        generated by generate_states.

        state_list: List of principal and spin quantum numbers, cf.
        generate_states.

    Return:
        A sparse matrix in the Compressed Sparse Row (CSR) format.
    """

    [nx_list, ny_list, spin_list] = state_list

    list_l = []  # left index
    list_r = []  # right index
    list_e = []  # entry

    # Precomputing the overlap lookup matrix for this translation amplitude
    lookup_array = _overlap_lookup(x0, ee_cutoff)

    # left index
    for li in range(0, len(nx_list), 2):  # ,2 implies translation for SPIN_UP
        nowNx = nx_list[li]
        nowNy = ny_list[li]
        for otherNx in range(0, ee_cutoff):
            if lookup_array[nowNx][otherNx] != 0:
                ri = state_index([otherNx, nowNy, SPIN_UP])
                if ri < len(nx_list):  # Not exceed the energy cutoff
                    list_l.append(li)
                    list_r.append(ri)
                    list_e.append(lookup_array[nowNx][otherNx])

    list_l = np.array(list_l)
    list_r = np.array(list_r)
    list_e = np.array(list_e)
    T = sps.coo_matrix((list_e, (list_l, list_r)),
                       shape=(len(nx_list), len(nx_list)))

    # Same overlaps for SPIN_DOWN
    list_lD = [x + 1 for x in list_l]
    list_rD = [x + 1 for x in list_r]

    T = T + sps.coo_matrix((list_e, (list_lD, list_rD)),
                           shape=(len(nx_list), len(nx_list)))

    return T


def generate_x_operator(state_list):
    """Construct the position operator X as a sparse matrix in the Cartesian
    harmonic oscillator basis.

    Args:
        state_list: List of principal and spin quantum numbers, cf.
        generate_states.

    Return:
        A sparse matrix in the Compressed Sparse Row (CSR) format.
    """
    [nx_list, ny_list, spin_list] = state_list

    list_l = []  # left index
    list_r = []  # right index
    list_e = []  # entry

    # left index
    for li in range(0, len(nx_list), 2):  # ,2 -> translation for SPIN_UP only
        if nx_list[li] > 0:
            ri = state_index([nx_list[li] - 1, ny_list[li], SPIN_UP])
            list_l.append(li)
            list_r.append(ri)
            list_e.append(sqrt(nx_list[li] / 2.))

        ri = state_index([nx_list[li] + 1, ny_list[li], SPIN_UP])
        if ri < len(nx_list):  # Not exceed the energy cutoff -- could optimize
            list_l.append(li)
            list_r.append(ri)
            list_e.append(sqrt((1 + nx_list[li]) / 2.))

    list_l = np.array(list_l)
    list_r = np.array(list_r)
    list_e = np.array(list_e)
    X = sps.coo_matrix((list_e, (list_l, list_r)),
                       shape=(len(nx_list), len(nx_list)))

    # Same overlaps for SPIN_DOWN
    list_lD = [x + 1 for x in list_l]
    list_rD = [x + 1 for x in list_r]

    X = X + sps.coo_matrix((list_e, (list_lD, list_rD)),
                           shape=(len(nx_list), len(nx_list)))

    return X


def generate_ysz_operator(state_list):
    """Construct the spin dipole operator YSZ as a sparse matrix in the
    Cartesian harmonic oscillator basis.

    Args:
        state_list: List of principal and spin quantum numbers, cf.
        generate_states.

    Return:
        A sparse matrix in the Compressed Sparse Row (CSR) format.
    """

    [nx_list, ny_list, spin_list] = state_list

    list_l = []  # left index
    list_r = []  # right index
    list_e = []  # entry

    # left index
    for li in range(0, len(nx_list), 2):
        if ny_list[li] > 0:
            ri = state_index([nx_list[li], ny_list[li] - 1, SPIN_UP])
            list_l.append(li)
            list_r.append(ri)
            list_e.append(sqrt(ny_list[li] / 2.))

        ri = state_index([nx_list[li], ny_list[li] + 1, SPIN_UP])
        if ri < len(nx_list):
            list_l.append(li)
            list_r.append(ri)
            list_e.append(sqrt((1 + ny_list[li]) / 2.))

    list_l = np.array(list_l)
    list_r = np.array(list_r)
    list_e = np.array(list_e)
    YSZ = sps.coo_matrix((list_e, (list_l, list_r)),
                         shape=(len(nx_list), len(nx_list)))

    # Same overlaps for spinDown
    list_lD = [x + 1 for x in list_l]
    list_rD = [x + 1 for x in list_r]

    # Note the flipped sign for spinDown
    YSZ = YSZ + sps.coo_matrix((-list_e, (list_lD, list_rD)),
                               shape=(len(nx_list), len(nx_list)))

    return YSZ
